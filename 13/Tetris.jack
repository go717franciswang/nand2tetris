class Tetris {
    field Array board;
    field int columnCount;
    field int rowCount;
    field Piece falling;
    field boolean gameRunning;
    static int KEYLEFT;
    static int KEYRIGHT;
    static int KEYSPACE;
    static int KEYDOWN;

    function void init() {
        let Tetris.KEYLEFT = 130;
        let Tetris.KEYRIGHT = 132;
        let Tetris.KEYSPACE = 32;
        let Tetris.KEYDOWN = 133;
        return;
    }

    function Tetris new() {
        var int i, j;
        var Array row;
        let columnCount = 10;
        let rowCount = 22;
        let board = Array.new(columnCount);

        let i = 0;
        while (i < rowCount) {
            let row = Array.new(columnCount);
            let board[i] = row;
            while (j < columnCount) {
                let row[j] = false;
                let j = j + 1;
            }
            let i = i + 1;
        }
        return this;
    }

    method void dispose() {
        return;
    }

    method void run() {
        let falling = getRandomPiece();
        let gameRunning = true;
        let gameTime = 0;
        let prevKey = null;
        while (gameRunning) {
            let key = getKey();
            if (~(key = prevKey)) {
                if (key = Tetris.KEYLEFT) {
                    do falling.moveLeft();
                    if (collides()) {
                        do falling.moveRight();
                    }
                }
                if (key = Tetris.KEYRIGHT) {
                    do falling.moveRight();
                    if (collides()) {
                        do falling.moveLeft();
                    }
                }
                if (key = Tetris.KEYSPACE) {
                    do falling.rotate();
                    if (collides()) {
                        do falling.rotateBack();
                    }
                }
                if (key = Tetris.KEYDOWN) {
                    do falling.moveDown();
                    if (collides()) {
                        do handleDownwardCollision();
                    }
                }
            }
            if (Util.mod(gameTime, 100) = 0) {
                falling.moveDown();
                if (collides()) {
                    do handleDownwardCollision();
                }
            }

            let gameTime = gameTime + 1;
            let prevKey = key;
        }
        return;
    }

    method boolean collides() {
        var Stack positions; 
        let positions = falling.computePositions();
        let pos = positions.pop();
        while (pos) {
            if (occupied(pos)) {
                positions.dispose();
                return true;
            }
            do pos.dispose();
            let pos = positions.pop();
        }
        do positions.dispose();

        return false;
    }

    method void handleDownwardCollision() {
        do falling.moveUp();
        do freeze(falling);
        do falling.dispose();
        do wipeConnectedRows();
        if (topRowOccoupied()) {
            let gameRunning = false;
        } else {
            let falling = getRandomPiece();
        }
        return;
    }

    method Piece getRandomPiece() {
        var int typ = Random.getNumber(0, 6);
        return Piece.new(typ);
    }
}
